#. extracted from ch2.txt
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-26 22:58+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 2.3.1\n"

#: ch2.txt:19
msgid ""
"2 \n"
"Designing a Great API \n"
"Regardless of whether you are experienced in building APIs and microservices "
"and looking for the techniques on how you can apply them with Go or you are "
"completely new to the world of microservices, it is worth spending the time "
"to read this chapter. \n"
"Writing an API contract feels part art, part science and, when you discuss "
"your design with other engineers, you will most certainly agree to disagree, "
"not to the level of tabs versus spaces, but there is certainly something "
"personal about API contracts. \n"
"In this chapter, we will look at the two most popular options, which are "
"RESTful and RPC. We will examine the semantics of each approach, which will "
"equip you with the knowledge to argue your case when the inevitable "
"discussion (read argument) occurs. Choosing between REST or RPC may be "
"entirely down to your current environment. If you currently have services "
"running that implement a RESTful approach, then I suggest you stick with it, "
"likewise if you now use RPC. One thing I would suggest is that you read the "
"entire chapter to understand the semantics, pros, and cons of each approach. "
"\n"
"RESTful APIs \n"
"The term REST was suggested by Roy Fielding in his Ph.D. dissertation in the "
"year 2000. It stands for Representational State Transfer and is described as:"
" \n"
"\"REST emphasizes scalability of component interactions, generality of "
"interfaces, \n"
"independent deployment of components, and intermediary components to reduce "
"\n"
"interaction latency, enforce security and encapsulate legacy systems.\" \n"
"Having an API that conforms to the REST principles is what makes it RESTful. "
"\n"
"URIs \n"
"One of the main components in the HTTP protocol is a URI. URI stands for "
"Uniform Resource Identifiers and is the method by which you will access the "
"API. You may be asking what the difference between a URI and a URL (Uniform "
"Resource Locator) is? When I started to write this chapter, I wondered about "
"this myself and did what any self-respecting developer would do, which is to "
"head over to Stack Overflow. Unfortunately, my confusion only grew as there "
"were lots of detailed answers, none of which I found particularly "
"enlightening. Time to head over to the inner circle of hell also known as "
"W3C standards to look up the RFC for the official answer. \n"
"In short, there is no difference, a URL is a URI that identifies a resource "
"by its network location, and it is acceptable to interchange the terms when "
"describing a resource entirely. \n"
"The clarification document published back in 2001 (http://www.w3.org/TR/uri-"
"clarification) goes on to explain that in the early to mid-90s there was an "
"assumption that an identifier is cast into one or two classes. An identifier "
"might specify the location of a resource (URL) or its name (Uniform Resource "
"Name URN) independent of location. A URI could either be a URL or a URN. "
"Using this example, http:// would be a URL scheme and isbn: a URN scheme. "
"However, this changed over time and the importance of the additional level "
"of hierarchy lessened. The view changed that an individual scheme does not "
"need to be cast into one of a discrete set of types. \n"
"The conventional approach is that http: is a URI scheme and urn: is also a "
"URI scheme. URNs take the form urn:isbn:n-nn-nnnnnn-n, isbn: is a URN "
"namespace identifier, not a URN scheme or a URI scheme. \n"
"Following this view, the term URL does not refer to a formal partition of "
"URI space rather, URL is an informal concept; a URL is a type of URI that "
"identifies a resource via its network location. \n"
"For the rest of this book, we will use the term URI and when we do we will "
"be talking about a method to access a resource that is running on a remote "
"server. "
msgstr ""

#: ch2.txt:25
msgid ""
"URI format \n"
"RFC 3986, which was published in 2005 https://www.ietf.org/rfc/rfc3986.txt, "
"defines the format that makes valid URIs: \n"
"URI = scheme \"://\" authority \"/\" path [ \"?\" query] [\"#\" fragment\"] "
"URI = http://myserver.com/mypath?query=1#document \n"
"We are will use the path element in order to locate an endpoint that is "
"running on our server. In a REST endpoint, this can contain parameters as "
"well as a document location. The query string is equally important, as you "
"will use this to pass parameters such as page number or ordering to control "
"the data that is returned. \n"
"Some general rules for URI formatting: "
msgstr ""

#: ch2.txt:28
msgid ""
"A\n"
" forward slash / is used to indicate a hierarchical relationship between "
"resources "
msgstr ""

#: ch2.txt:32
msgid ""
"A\n"
" trailing forward slash / should not be included in URIs "
msgstr ""

#: ch2.txt:36
msgid ""
"Hyphens \n"
"- should be used to improve readability "
msgstr ""

#: ch2.txt:40
msgid ""
"Underscores \n"
"_ should not be used in URIs "
msgstr ""

#: ch2.txt:44
msgid ""
"Lowercase\n"
" letters are preferred as case sensitivity is a differentiator in the path "
"part of a URI "
msgstr ""

#: ch2.txt:47
msgid ""
"The concept behind many of the rules is that a URI should be easy to read "
"and to construct. It should also be consistent in the way that it is built "
"so you should follow the same taxonomy for all the endpoints in your API. "
msgstr ""

#: ch2.txt:54
msgid ""
"URI path design for REST services \n"
"Paths are broken into documents, collections, stores, and controllers. \n"
"Collections \n"
"A collection is a directory of resources typically broken by parameters to "
"access an individual document. For example: \n"
"GET /cats  -> All cats in the collection GET /cats/1 -> Single document for "
"a cat 1 \n"
"When defining a collection, we should always use a plural noun such as cats "
"or people for the collection name. "
msgstr ""

#: ch2.txt:58
msgid ""
"Documents \n"
"A document is a resource pointing to a single object, similar to a row in a "
"database. It has the ability to have child resources that may be both sub-"
"documents or collections. For example: \n"
"GET /cats/1  -> Single document for cat 1 GET /cats/1/kittens  -> All "
"kittens belonging to cat 1 GET /cats/1/kittens/1 -> Kitten 1 for cat 1 "
msgstr ""

#: ch2.txt:64
msgid ""
"Controller \n"
"A controller resource is like a procedure, this is typically used when a "
"resource cannot be mapped to standard CRUD (create, retrieve, update, and "
"delete) functions. \n"
"The names for controllers appear as the last segment in a URI path with no "
"child resources. If the controller requires parameters, these would "
"typically be included in the query string: \n"
"POST /cats/1/feed  -> Feed cat 1 POST /cats/1/feed?food=fish ->Feed cat 1 a "
"fish \n"
"When defining a controller name we should always use a verb. A verb is a "
"word that indicates an action or a state of being, such as feed or send. "
msgstr ""

#: ch2.txt:69
msgid ""
"Store \n"
"A store is a client-managed resource repository, it allows the client to "
"add, retrieve, and delete resources. Unlike a collection, a store will never "
"generate a new URI it will use the one specified by the client. Take a look "
"at the following example that would add a new cat to our store: \n"
"PUT /cats/2 \n"
"This would add a new cat to the store with an ID of 2, if we had posted the "
"new cat omitting the ID to a collection the response would need to include a "
"reference to the newly defined document so we could later interact with it. "
"Like controllers we should use a plural noun for store names. "
msgstr ""

#: ch2.txt:76
msgid ""
"CRUD function names \n"
"When designing great REST URIs we never use a CRUD function name as part of "
"the URI, instead we use a HTTP verb. For example: \n"
"DELETE /cats/1234 \n"
"We do not include the verb in the name of the method as this is specified by "
"the HTTP verb, the following URIs would be considered an anti-pattern: \n"
"GET /deleteCat/1234 DELETE /deleteCat/1234 POST /cats/1234/delete \n"
"When we look at HTTP verbs in the next section this will make more sense. "
msgstr ""

#: ch2.txt:80
msgid ""
"HTTP verbs \n"
"The commonly used HTTP verbs are: "
msgstr ""

#: ch2.txt:82
msgid "GET POST PUT PATCH DELETE HEAD OPTIONS "
msgstr ""

#: ch2.txt:96
msgid ""
"Each of these methods has a well-defined semantic within the context of our "
"REST API and the correct implementation will help your user understand your "
"intention. \n"
"GET \n"
"The GET method is used to retrieve a resource and should never be used to "
"mutate an operation, such as updating a record. Typically, a body is not "
"passed with a GET request; however, it is not an invalid HTTP request to do "
"so. \n"
"Request: \n"
"GET /v1/cats HTTP/1.1 \n"
"Response: \n"
"HTTP/1.1 200 OK Content-Type: application/json Content-Length: xxxx \n"
"{\"name\": \"Fat Freddie's Cat\", \"weight\": 15} "
msgstr ""

#: ch2.txt:110
msgid ""
"POST \n"
"The POST method is used to create a new resource in a collection or to "
"execute a controller. It is typically a non-idempotent action, in that "
"multiple posts to create an element in a collection that will create "
"multiple elements not updated after the first call. \n"
"The POST method is always used when calling controllers as the actions of "
"this is considered non-idempotent. \n"
"Request: \n"
"POST /v1/cats HTTP/1.1 Content-Type: application/json Content-Length: xxxx \n"
"{\"name\": \"Felix\", \"weight\": 5} \n"
"Response: \n"
"HTTP/1.1 201 Created Content-Type: application/json Content-Length: 0 "
"Location: /v1/cats/12343 \n"
"PUT \n"
"The PUT method is used to update a mutable resource and must always include "
"the resource locator. The PUT method calls are also idempotent in that "
"multiple requests will not mutate the resource to a different state than the "
"first call. \n"
"Request: \n"
"PUT /v1/cats HTTP/1.1 Content-Type: application/json Content-Length: xxxx \n"
"{\"name\": \"Thomas\", \"weight\": 7 } "
msgstr ""

#: ch2.txt:113
msgid ""
"Response: \n"
"HTTP/1.1 201 Created Content-Type: application/json Content-Length: 0 "
msgstr ""

#: ch2.txt:122
msgid ""
"PATCH \n"
"The PATCH verb is used to perform a partial update, for example, if we only "
"wanted to update the name of our cat we could make a PATCH request only "
"containing the details that we would like to change. \n"
"Request: \n"
"PATCH /v1/cats/12343 HTTP/1.1 Content-Type: application/json Content-Length: "
"xxxx \n"
"{\"weight\": 9} \n"
"Response: \n"
"HTTP/1.1 204 No Body Content-Type: application/json Content-Length: 0 \n"
"In my experience PATCH updates are rarely used, the general convention is to "
"use a PUT and to update the whole object, this not only makes the code "
"easier to write but also makes an API which is simpler to understand. "
msgstr ""

#: ch2.txt:127
msgid ""
"DELETE \n"
"The DELETE verb is used when we want to remove a resource, generally we "
"would pass the ID of the resource as part of the path rather than in the "
"body of the request. This way, we have a consistent method for updating, "
"deleting, and retrieving a document. \n"
"Request: \n"
"DELETE /v1/cats/12343 HTTP/1.1 Content-Type: application/json Content-Length:"
" 0 "
msgstr ""

#: ch2.txt:130
msgid ""
"Response: \n"
"HTTP/1.1 204 No Body Content-Type: application/json Content-Length: 0 "
msgstr ""

#: ch2.txt:137
msgid ""
"HEAD \n"
"A client would use the HEAD verb when they would like to retrieve the "
"headers for a resource without the body. The HEAD verb is typically used in "
"place of a GET verb when a client only wants to check if a resource exists "
"or to read the metadata. \n"
"Request: \n"
"HEAD /v1/cats/12343 HTTP/1.1 Content-Type: application/json Content-Length: "
"0 \n"
"Response: \n"
"HTTP/1.1 200 OK Content-Type: application/json Last-Modified: Wed, 25 Feb "
"2004 22:37:23 GMT Content-Length: 45 "
msgstr ""

#: ch2.txt:144
msgid ""
"OPTIONS \n"
"The OPTIONS verb is used when a client would like to retrieve the possible "
"interactions for a resource. Typically, the server will return an Allow "
"header, which will include the HTTP verbs that can be used with this "
"resource. \n"
"Request: \n"
"OPTIONS /v1/cats/12343 HTTP/1.1 Content-Length: 0 \n"
"Response: \n"
"HTTP/1.1 200 OK Content-Length: 0 Allow: GET, PUT, DELETE "
msgstr ""

#: ch2.txt:148
msgid ""
"URI query design \n"
"It is perfectly acceptable to use a query string as part of an API call; "
"however, I would refrain from using this to pass data to the service. "
"Instead the query should be used to perform actions such as: "
msgstr ""

#: ch2.txt:150
msgctxt "ch2.txt:150"
msgid "Paging Filtering Sorting "
msgstr ""

#: ch2.txt:161
msgid ""
"If we need to make a call to a controller, we discussed earlier that we "
"should use a POST request as this is most likely a non-idempotent request. "
"To pass data to the service, we should include the data inside of the body. "
"However, we could use a query string to filter the action of the controller: "
"\n"
"POST /sendStatusUpdateEmail?$group=admin \n"
"{\n"
"  \"\"message\": \"\": \"All services are now operational\\n"
"Please accept our\n"
"              apologies for any inconvenience caused.\\n"
"\n"
"              The Kitten API team\"\" \n"
"} \n"
"In the preceding example, we would send a status update email with the "
"message included in the body of the request, because we are using the group "
"filter passed in the query string we could restrict the action of this "
"controller to only send to the admin group. \n"
"If we had added the message to the query string and not passed a message "
"body, then we would potentially be causing two problems for ourselves. The "
"first is that the max length for a URI is 2083 characters. The second is "
"that generally a POST request would always include a request body. Whilst "
"this is not required by the HTTP specification, it would be expected "
"behavior by the majority of your users. "
msgstr ""

#: ch2.txt:193
msgid ""
"Response codes \n"
"When writing a great API, we should use HTTP status codes to indicate to the "
"client the success or failure of the request. In this chapter, we will not "
"be taking a comprehensive look at all the status codes available; there are "
"many resources on the Internet that have this information. We will provide "
"some sources for further reading, what we will do is look at the status "
"codes that you as a software engineer will want your microservice to return. "
"\n"
"Currently, it is a generally held consensus that this is good practice as it "
"allows the client to immediately determine the status of a request without "
"having to dive into the request body to gain further insight. In the "
"instance of a failure and APIs that always return a 200 OK response to the "
"user with a message body containing further information is not good practice "
"as it requires the client to have to inspect the body to determine outcome. "
"It also means that the message body will contain additional information "
"other than the object that it should represent. Consider the following bad "
"practice: \n"
"Bad request body: \n"
"POST /kittens RESPONSE HTTP 200 OK {\n"
"  \"\"status\":\": 401,  \"\"statusMessage\": \"\": \"Bad Request\"\" } \n"
"Successful request: \n"
"POST /kittens RESPONSE HTTP 201 CREATED {\n"
"  \"\"status\":\": 201,  \"\"statusMessage\": \"\": \"Created\",\",  \"\""
"kitten\":\": {\n"
"    \"\"id\": \"\": \"1234334dffdf23\",\",    \"\"name\": \"\": \"Fat "
"Freddy'sFreddy's Cat\"\"  } } \n"
"Imagine if you were writing a client for the preceding request, you need to "
"add logic to your application to check the status node in the response "
"before you could read and process the returned kitten. \n"
"Now consider something even worse: \n"
"And even worse failure: \n"
"POST /kittens RESPONSE HTTP 200 OK {\n"
"  \"\"status\":\": 400,  \"\"statusMessage\": \"\": \"Bad Request\"\" } \n"
"And even worse success: \n"
"POST /kittens RESPONSE HTTP 200 OK {\n"
"  \"\"id\": \"\": \"123434jhjh3433\",\",  \"\"name\": \"\": \"Fat "
"Freddy'sFreddy's Cat\"\" } \n"
"If your API author had done something like the preceding example, you need "
"to check to see if the response that has been returned is an error or the "
"kitten that you were expecting. The number of WTFs per minute you would "
"utter whilst coding a client for this API would not endear you to its "
"author. These might seem like extreme examples, but there are instances like "
"this out in the wild, at some point in my career I'm fairly sure I have been "
"guilty of such a crime, but then I had not read this book. \n"
"What the author in their best intention has done is try to take the HTTP "
"status codes too literally. W3C RFC2616 states that the HTTP status code "
"relates to the attempt to understand and satisfy the request (https://www.w3."
"org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.1); however, this is a little "
"ambiguous when you look at some of the individual status codes. Modern "
"consensus is that it is OK to use HTTP status codes to indicate the "
"processing state of an API request not just the server's ability to process "
"the request. Consider how we could make these requests better by "
"implementing this approach. \n"
"A good example of a failure: \n"
"POST /kittens RESPONSE HTTP 400 BAD REQUEST {\n"
"  \"\"errorMessage\": \"\": \"Name should be between 1 and 256 characters "
"in  length and only contain [A-Z] - ['-.]\"'-.]\" } \n"
"A good example of a success: \n"
"POST /kittens RESPONSE HTTP 201 CREATED {\n"
"  \"\"id\": \"\": \"123hjhjh2322\",\",  \"\"name\": \"\": \"Fat "
"Freddy'sFreddy's cat\"\" } \n"
"This is far more semantic; the user only ever needs to read the response in "
"the instance of a failure if they require further information. In addition "
"to this we can provide a standard error object that is used across all the "
"endpoints of our API, which provides further but non-required information to "
"determine why a request failed. We will look at error objects in a little "
"while, but for now let's look at HTTP status codes more in depth. \n"
"2xx Success \n"
"2xx status codes indicate that the clients request has been successfully "
"received and understood. \n"
"200 OK \n"
"This is a generic response code indicating that the request has succeeded. "
"The response accompanying this code is generally: "
msgstr ""

#: ch2.txt:195
msgid "GET: An, an entity corresponding to the requested resource "
msgstr ""

#: ch2.txt:197
msgid ""
"HEAD: The, the header fields corresponding to the requested resource without "
"the message body "
msgstr ""

#: ch2.txt:199
msgid "POST: An, an entity describing or containing the result of the action "
msgstr ""

#: ch2.txt:204
msgid ""
"201 Created \n"
"The created response is sent when a request succeeds and the result is that "
"a new entity has been created. Along with the response it is common that the "
"API will return a Location header with the location of the newly created "
"entity: \n"
"201 Created Location: https://api.kittens.com/v1/kittens/123dfdf111 \n"
"It is optional to return an object body with this response type. "
msgstr ""

#: ch2.txt:207
msgid ""
"204 No Content \n"
"This status informs the client that the request has been successfully "
"processed; however, there will be no message body with the response. For "
"example, if the user makes a DELETE request to the collection then the "
"response may return a 204 status. "
msgstr ""

#: ch2.txt:213
msgid ""
"3xx Redirection \n"
"The 3xx indicate class of status codes indicates that the client must take "
"additional action to complete the request. Many of these status codes are "
"used by CDNs and other content redirection techniques, however, code 304 can "
"exceptionally useful when designing our APIs to provide semantic feedback to "
"the client. \n"
"301 Moved Permanently \n"
"This tells the client that the resource they have requested has been "
"permanently moved to a different location. Whilst this is traditionally used "
"to redirect a page or resource from a web server it can also be useful to us "
"when we are building our APIs. In the instance that we rename a collection "
"we could use a 301 redirect to send the client to the correct location. This "
"however should be used as an exception rather than the norm. Some clients do "
"not implicitly follow 301 redirect and implementing this capability adds "
"additional complexity for your consumers. "
msgstr ""

#: ch2.txt:216
msgid ""
"304 Not Modi.ed \n"
"This response is generally used by a CDN or caching server and is set to "
"indicate that the response has not been modified since the last call to the "
"API. This is designed to save bandwidth and the request will not return a "
"body, but will return a Content-Location and Expires header. "
msgstr ""

#: ch2.txt:222
msgid ""
"4xx Client Error \n"
"In the instance of an error caused by a client, not the server, the server "
"will return a 4xx response and will always return an entity that gives "
"further details on the error. \n"
"400 Bad Request \n"
"This response indicates that the request could not be understood by the "
"client due to a malformed request or due to a failure of domain validation ("
"missing data, or an operation that would cause invalid state). "
msgstr ""

#: ch2.txt:225
msgid ""
"401 Unauthorized \n"
"This indicates that the request requires user authentication and will "
"include a WWW-Authenticate header containing a challenge applicable to the "
"requested resource. If the user has included the required credentials in the "
"WWW-Authenticate header, then the response should include an error object "
"that may contain relevant diagnostic information. "
msgstr ""

#: ch2.txt:229
msgid ""
"403 Forbidden \n"
"The server has understood the request, but is refusing to fulfill it. This "
"could be due to incorrect access level to a resource not that the user is "
"not authenticated. \n"
"If the server does not wish to make the fact that a request is not able to "
"access a resource due to access level public, then it is permissible to "
"return a 404 Not found status instead of this response. "
msgstr ""

#: ch2.txt:233
msgid ""
"404 Not Found \n"
"This response indicates that the server has not found anything matching the "
"requested URI. No indication is given of whether the condition is temporary "
"or permanent. \n"
"It is permissible for the client to make multiple requests to this endpoint "
"as the state may not be permanent. "
msgstr ""

#: ch2.txt:236
msgid ""
"405 Method Not Allowed \n"
"The method specified in the request is not allowed for the resource "
"indicated by the URI. This may be when the client attempts to mutate a "
"collection by sending a POST, PUT, or PATCH to a collection that only serves "
"retrieval of documents. "
msgstr ""

#: ch2.txt:239
msgid ""
"408 Request Timeout \n"
"The client did not produce a request within the time that the server is "
"prepared to wait. The client may repeat the request without modification at "
"a later time. "
msgstr ""

#: ch2.txt:246
msgid ""
"5xx Server Error \n"
"Response status codes within the 500 range indicate that something has gone "
"\"Bang\", the server knows this and is sorry for the situation. \n"
"The RFC advises that an error entity should be returned in the response "
"explaining whether this is permanent or temporary and containing an "
"explanation of the error. When we look at our chapter on security we will "
"look at the recommendation about not giving too much information away in "
"error messages as this state may have been engineered by a user in the "
"attempt to compromise your system and by returning things such as a stack "
"trace or other internal information with a 5xx error can actually help to "
"compromise your system. With this in mind it is currently common that a 500 "
"error will just return something very generic. \n"
"500 Internal Server Error \n"
"A generic error message indicating that something did not go quite as "
"planned. "
msgstr ""

#: ch2.txt:249
msgid ""
"503 Service Unavailable \n"
"The server is currently unavailable due to temporary overloading or "
"maintenance. There is a rather useful pattern that you can implement to "
"avoid cascading failure in the instance of a malfunction in which the "
"microservice will monitor its internal state and in the case of failure or "
"overloading will refuse to accept the request and immediately signal this to "
"the client. We will look at this pattern more in chapter xx; however, this "
"instance is probably where you will be wanting to return a 503 status code. "
"This could also be used as part of your health checks. "
msgstr ""

#: ch2.txt:270
msgid ""
"HTTP headers \n"
"Request headers are a really important part of the HTTP request and response "
"process and implementing a standard approach helps your users to transition "
"from one API to another. In this sub section, we will not cover all the "
"possible headers that you can use in your API, but we will look at the most "
"common headers for full information on the HTTP protocol please take a look "
"at RFC 7231 https://tools.ietf.org/html/rfc7231. This document contains a "
"comprehensive overview of the current standard. \n"
"Standard request headers \n"
"Request headers provide additional information for the request and the "
"response of your API. Think of them like metadata for the operation. They "
"can be used to augment other data for the response that does not belong in "
"the body itself such as the content encoding. They can also be utilized by "
"the client to provide information that can help the server process the "
"response. Where possible we should always use the standard headers as this "
"gives consistency to your user and provides them with a common standard "
"across multiple endpoints from many different vendors. \n"
"Authorization - string \n"
"Authorization is one of the most commonly used request headers, even if you "
"have a public read only API I advise you to ask the user to authorize their "
"requests. By requesting that the user authorizes a request, you have the "
"capability to perform operations such as user level logging and rate "
"limiting. Quite often you may see authorization conducted with a custom "
"request header such as \"X-API-Authorization\". I would recommend you do not "
"use this approach as the standard Authorization header as specified by the "
"W3C RFC 2616 (https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) has "
"all the capability we need. Many companies such as Twitter and PayPal use "
"this header to authenticate requests let's. Let's look at a simple example "
"from Twitter's developer documentation to see how this can be implemented: \n"
"Authorization:\n"
"        OAuth oauth_consumer_key=\"=\"xvz1evFS4wEEPTGEFPHBog\",\",\n"
"              oauth_nonce=\"=\"kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg\","
"\",\n"
"              oauth_signature=\"=\"tnnArxj06cWHq44gCs1OSKk%2FjLY%3D\",\",\n"
"              oauth_signature_method=\"=\"HMAC-SHA1\",\",\n"
"              oauth_timestamp=\"=\"1318622958\",\",\n"
"              oauth_token=\"=\"370773112-\n"
"GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb\",\",\n"
"              oauth_version=\"=\"1.0\"\" \n"
"The header is in the form of [Authorization method] [Comma separated URL "
"encoded values]. This clearly informs the server that the authorization type "
"is OAuth and the various components of this authorization follow this in a "
"comma delaminated format. By following this standard approach you can enable "
"your consumers to use a third-party library that implements this standard "
"and thus save them the work of having to build a bespoke implementation. \n"
"Date \n"
"Timestamp of the request in RFC 3339 format. "
msgstr ""

#: ch2.txt:273
msgid ""
"Accept - content type \n"
"The requested content type for the response, such as: "
msgstr ""

#: ch2.txt:275
msgid "application/xml text/xml application/json "
msgstr ""

#: ch2.txt:279
msgid "text/javascript (for JSONP) "
msgstr ""

#: ch2.txt:296
msgid ""
"Accept-Encoding - gzip, de.ate \n"
"REST endpoints should always support gzip and deflate encoding, when "
"applicable. \n"
"Implementing gzip support in Go is relatively straightforward; we showed how "
"it is possible to implement middleware into your microservices in Chapter 1, "
"Introduction to Microservices. In the following example, we will use this "
"technique to create a gzip response writer. \n"
"The core of writing a response in a gzipped format is the compress/gzip "
"package, which is part of the standard library. It allows you to create a "
"Writer interface that implements ioWriteCloser wrapping an existing "
"io.Writer, which writes to the given writer using the gzip compression: \n"
"func NewWriter(w io.Writer) *Writer \n"
"To create our handler we are going to write the NewGzipHandler function, "
"this returns a new http.Handler that will wrap our standard output handler. "
"\n"
"The first thing we need to do is create our own ResponseWriter that embeds "
"http.ResponseWriter. \n"
"Example 2.1 chapter2/gzip/gzip_deflate.go: \n"
"68 type GzipResponseWriter struct { 69  gw *gzip.Writer 70  "
"http.ResponseWriter 71} \n"
"The core method for this is the implementation of the Write method: \n"
"73 func (w GzipResponseWriter) Write(b []byte) (int, error) { \n"
"74   if _, ok := w.Header()[\"()[\"Content-Type\"];\"]; !ok {  \n"
"75   // If content type is not set, infer it from the uncompressed body.  \n"
"76   w.Header().Set(\"(\"Content-Type\",\", http.DetectContentType(b))  \n"
"77   }  \n"
"78   return w.gw.Write(b)  "
msgstr ""

#: ch2.txt:303
msgid ""
"79 } \n"
"If you look at the implementation for Write in the standard http.Response "
"struct there is a whole load of stuff going on in there that we neither want "
"to lose or re-implement because the gzip.Writer object is created with a "
"writer when we call Write on it, it then in turn calls write on "
"http.Response and we lose none of the complexity. \n"
"Internally in our NewGzipHandler our handler checks to see if the client has "
"sent the Accept-Encoding header and if so we will write the response using "
"the GzipResponseWriter method if the client has requested uncompressed "
"content then we only call ServeHttp with the standard ResponseWriter: \n"
"40 type GZipHandler struct { 41  next http.Handler \n"
"42\n"
" } 43 44 func (h *GZipHandler) ServeHTTP(w http.ResponseWriter, r "
"*http.Request) { 45  encodings := r.Header.Get(\"(\"Accept-Encoding\")\") 46 "
"47  if strings.Contains(encodings, \"\"gzip\")\") { 48  h.serveGzipped(w, r) "
msgstr ""

#: ch2.txt:306
msgid ""
"49  \n"
"} else if strings.Contains(encodings, \"\"deflate\")\") { 50  panic(\"(\""
"Deflate not implemented\")\") "
msgstr ""

#: ch2.txt:309
msgid ""
"51  \n"
"} else { 52  h.servePlain(w, r) "
msgstr ""

#: ch2.txt:312
msgid ""
"53  \n"
"} "
msgstr ""

#: ch2.txt:315
msgid ""
"54\n"
" } 55 56 func (h *GZipHandler) serveGzipped(w http.ResponseWriter, r "
"*http.Request) { 57  gzw := gzip.NewWriter(w) 58  defer gzw.Close() 59 60  "
"w.Header().Set(\"(\"Content-Encoding\", \"\", \"gzip\")\") 61  "
"h.next.ServeHTTP(GzipResponseWriter{gzw, w}, r) "
msgstr ""

#: ch2.txt:318
msgid ""
"62\n"
" } "
msgstr ""

#: ch2.txt:320
msgid ""
"63 func (h *GZipHandler) servePlain(w http.ResponseWriter, r *http.Request) "
"64 { 65  h.next.ServeHTTP(w, r) "
msgstr ""

#: ch2.txt:323
msgid ""
"66\n"
" } "
msgstr ""

#: ch2.txt:327
msgid ""
"This is by no means a comprehensive example and there are many open source "
"packages like the one from the team at the NY Times (https://github.com/"
"NYTimes/gziphandler), which manages this for you. \n"
"As a little programming test, why not try and modify this example to "
"implement DEFLATE. "
msgstr ""

#: ch2.txt:331
msgid ""
"Standard response headers \n"
"All services should return the following headers. "
msgstr ""

#: ch2.txt:333
msgid "Date: The date that the request was processed in RFC 3339 format. "
msgstr ""

#: ch2.txt:335
msgid "Content-Type: The content type of the response. "
msgstr ""

#: ch2.txt:337
msgid "Content-Encoding: gzip or deflate. "
msgstr ""

#: ch2.txt:340
msgid ""
"X-Request-ID/X-Correlation-ID: Whilst you may not directly request your "
"clients to implement this header it may be something that you add to "
"requests when you call downstream services. When you are trying to debug a "
"service that is running in production it can be incredibly useful to be able "
"to group all the requests by a single transaction ID. A common practice that "
"we will see when we look at logging and monitoring is to store all logs in a "
"common database such as Elastic Search. By setting the standard way of "
"working when building many connected microservices that they pass the "
"correlation ID with each downstream call you will be able to query your logs "
"in Kibana or another log query tool and group them into a single transaction:"
"\n"
"        X-Request-ID: f058ebd6-02f7-4d3f-942e-904344e8cde "
msgstr ""

#: ch2.txt:355
msgid ""
"Returning errors \n"
"In the instance of failure, users of your API should be able to write one "
"piece of code that handles errors across different endpoints. A standard "
"error entity will help your consumers by enabling them to write DRY code "
"whenever an error caused by client or server occurs. \n"
"The Microsoft API guidelines recommend the following format for these "
"entities: \n"
"{\n"
"  \"\"error\":\": {    \"\"code\": \"\": \"BadArgument\",\",    \"\"message\""
": \"\": \"Previous passwords may not be reused\",\",    \"\"target\": \"\": "
"\"password\",\",    \"\"innererror\":\": a {\n"
"      \"\"code\": \"\": \"PasswordError\",\",\n"
"  \"\"innererror\":\": {    \"\"code\": \"\": \"PasswordDoesNotMeetPolicy\","
"\",    \"\"minLength\": \"\": \"6\",\",    \"\"maxLength\": \"\": \"64\",\""
",    \"\"characterTypes\": [\"\": \n"
"[\"lowerCase\",\"\",\"upperCase\",\"\",\"number\",\"\",\"symbol\"],\"],    \""
"\"minDistinctCharacterTypes\": \"\": \"2\",\",    \"\"innererror\":\": { \n"
"      \"\"code\": \"\": \"PasswordReuseNotAllowed\"\"    }      }    }  } } "
"\n"
"ErrorResponse: Object \n"
"The ErrorResponse is the top level object which will be returned by our "
"response and contains the following fields: \n"
"Property  Type  Required  Description  \n"
"error  Error  \n"
" The error object.  "
msgstr ""

#: ch2.txt:366
msgid ""
"Error: Object \n"
"The Error object is the detail for our error response; it provides full "
"detail for the reason that the error occurred: \n"
"Property  Type  Required  Description  \n"
"Code  String (enumerated)  \n"
" One of a server-defined set of error codes.  \n"
"message  String  \n"
" A human-readable representation of the error.  \n"
"Target  String  - The target of the error.  \n"
"Details  Error[]  - An array of details about specific errors that led to "
"this reported error.  \n"
"innererror  InnerError  - An object containing more specific information "
"than the current object about the error.  "
msgstr ""

#: ch2.txt:372
msgid ""
"InnerError: Object \n"
"Property  Type  Required  Description  \n"
"Code  String  - A more specific error code than was provided by the "
"containing error.  \n"
"innererror  InnerError  - An object containing more specific information "
"than the current object about the error.  "
msgstr ""

#: ch2.txt:375
msgid ""
"Microsoft has provided an excellent API guidelines resource, you can read "
"more about returning errors by looking at the following link: \n"
"https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md#51-"
"errors "
msgstr ""

#: ch2.txt:401
msgid ""
"Accessing APIs from JavaScript \n"
"Web browsers implement a sandbox mechanism that restricts resources in one "
"domain from accessing resources in another. For example, you may have an API "
"that allows the modification and retrieval of user data and a website that "
"provides an interface for this API. If the browser did not implement the \""
"same-origin policy\" and assuming the user did not log out of their session "
"then it would be possible for a malicious page to send a request to the API "
"and modify it without you knowing. \n"
"To get around this, there are two methods that can be implemented by your "
"microservice to allow this access, JSONP which stands for (JSON with Padding)"
" and CORS (Cross-Origin Resource Sharing). \n"
"JSONP \n"
"JSONP is pretty much a hack, and it is implemented by most browsers that do "
"not implement the later CORS standard. It is restricted to GET requests only "
"and works by getting round the issue that while XMLHTTPRequest is blocked "
"from making requests to third-party servers, there are no restrictions on "
"HTML script elements. \n"
"A JSONP request inserts a <script src=\"...\"> element into the browsers DOM "
"with the API's URI as the src target. This component returns a function call "
"with the JSON data as a parameter, and when this loads, the function "
"executes passing the data to the callback. \n"
"JavaScript callback is defined in the code: \n"
"function success(data) {\n"
"  alert(data.message); \n"
"} \n"
"This is the response from the API call: \n"
"success({\"({\"message\":\"\":\"Hello World\"})\"}) \n"
"To denote a request for data to be returned as JSONP, generally the callback="
"functionName parameter is added to the URI, in our example this would be "
"/helloworld?callback=success. Implementing this is particularly "
"straightforward let's take a look at our simple Go helloworld example and "
"see how we can modify this to implement JSONP. \n"
"One thing to note is the Content-Type header that we are returning. We are "
"no longer returning application/json as we are not returning JSON we are "
"actually returning JavaScript so we must set the Content-Type header "
"accordingly: \n"
"Content-Type: application/javascript \n"
"Example chapter2/jsonp/jsonp.go: \n"
"Let's take a quick look at an example of how we can send JSONP with Go, our "
"response object is going to be exactly the same as the ones in Chapter 1, "
"Introduction to Microservices: \n"
"18 type helloWorldResponse struct { 19  Message string `json:\":\"message\"`"
"\"` \n"
"20 } \n"
"The difference is all in the handler, if we look at line 30 we are checking "
"to see if there is a callback parameter in the query string. This would be "
"provided by the client and indicates the function they expect to be called "
"when the response is returned: \n"
"23 func helloWorldHandler(w http.ResponseWriter, r *http.Request) { 24  "
"response := helloWorldResponse{Message: \"\"HelloWorld\"}\"} 25  data, err :="
" json.Marshal(response) 26  if err != nil { 27  panic(\"(\"Ooops\")\") \n"
"28\n"
" } 29 30  callback := r.URL.Query().Get(\"(\"callback\")\") 31  if callback "
"!= \"\"\"\" { 32  r.Headers().Add(\"(\"Content-Type\", \"\", \"application/"
"javascript\")\") 33  fmt.Fprintf(w, \"%\"%s(%s)\",)\", callback, "
"string(data)) "
msgstr ""

#: ch2.txt:404
msgid ""
"34  \n"
"} else { "
msgstr ""

#: ch2.txt:406
msgid "35  fmt.Fprint(w, string(data)) "
msgstr ""

#: ch2.txt:409
msgid ""
"36  \n"
"} "
msgstr ""

#: ch2.txt:412
msgid ""
"37\n"
" } "
msgstr ""

#: ch2.txt:419
msgid ""
"To return our response in JSONP format all we need to do is wrap the "
"standard response to a JavaScript function call. In line 33, we are taking "
"the callback function name that was passed by the client and encapsulating "
"the response we would normally send. The resultant output would look "
"something like this: \n"
"Request: \n"
"GET /helloworld?callback=hello \n"
"Response: \n"
"hello({\"message\":\"Hello World\"}) "
msgstr ""

#: ch2.txt:431
msgid ""
"CORS \n"
"Assuming your users are using a desktop browser that has been released in "
"the last five years, or a mobile browser such as iOS 9 or Android 4.2+, then "
"implementing CORS will be more than enough. http://caniuse.com/#feat=cors "
"says that it is over 92% of all Internet users. I was looking forward to "
"bashing IE for the lack of full adoption; however, since this has been "
"supported since IE8 I will have to complain about mobile users. \n"
"CORS is a W3C proposal to standardize cross-origin requests from the "
"browser. It works by the browsers built in HTTP client making an OPTIONS "
"request to a URI before the real request. \n"
"If the server at the other end returns a header that contains the origin of "
"the domain from which the script is being loaded, then the browser will "
"trust the server and will allow a cross-site request to be made: \n"
"Access-Control-Allow-Origin: origin.com \n"
"Implementing this in Go is quite straightforward and we could create a "
"middleware to globally manage this for us. For simplicity, in our example we "
"have hard coded this into the handler: \n"
"Example 2.2 chapter2/cors/cors.go 25 if r.Method == \"\"OPTIONS\"\" { \n"
"26   w.Header().Add(\"(\"Access-Control-Allow-Origin\", \"*\")\", \"*\")  \n"
"27   w.Header().Add(\"(\"Access-Control-Allow-Methods\", \"\", \"GET\")\")  "
"\n"
"28   w.WriteHeader(http.StatusNoContent)  \n"
"29   return  "
msgstr ""

#: ch2.txt:436
msgid ""
"30 } \n"
"In line 25, we detect if the request method is OPTIONS and instead of "
"returning the response we return the Access-Control-Allow-Origin header that "
"the client is expecting. In our example, we are simply returning \\*, which "
"means all domains are allowed to interact with this API. This is not the "
"safest implementation and quite often you will request your API users to "
"register the domains that will be interacting with the API and restrict the "
"Allow-Origin to only include those domains. In addition to the Allow-Origin "
"header we are also returning the following: \n"
"Access-Control-Allow-Methods: GET \n"
"This tells the browser that it can only make GET requests to this URI and "
"that it is forbidden to make POST, PUT, and so on. This is an optional "
"header, but it can be used to enhance your user's security when interacting "
"with the API. One thing to note is that we are not sending back a 200 OK "
"response we are using 204 No Content since it is invalid to return a body "
"with an OPTIONS request. "
msgstr ""

#: ch2.txt:458
msgid ""
"RPC APIs \n"
"RPC stands for remote procedure call; it is a method of executing a function "
"or method on a remote machine. RPC has been around since the dawn of time "
"and there are many different types of RPC technology some of which relies on "
"there being an interface definition (SOAP, Thrift Protocol Buffers). This "
"interface definition can make it easier to generate client and server stubs "
"for different technology stacks. Generally, the interface is defined using a "
"DSL (domain specific language) and a generator program will use this to "
"create application clients and servers. \n"
"Where REST needs to use HTTP as a transport layer, RPC is not bound by this "
"constraint, and while it is possible to send RPC calls over HTTP, you can "
"use the lightness of TCP or even UDP sockets if you choose to. \n"
"RPC has seen a resurgence in use lately with many large-scale systems built "
"by the likes of Uber, Google, Netflix, and so on are using RPC. Due to the "
"speed and performance that you can get from the lower latency from not using "
"HTTP and the smaller message size attained by implementing a binary message "
"format rather than JSON or XML. \n"
"The detractors of RPC mention the tight coupling that can occur between the "
"client and the server in that if you update the contract on the server then "
"all the clients need to be updated too. With many modern RPC implementations "
"this is less of a problem and in fact is no less a problem than you can have "
"with RESTful APIs. Whilst old technology such as JMI was tightly bound, "
"requiring the client and the server to share the same interface, modern "
"implementations such as Protocol Buffers marshal the object sensibly and "
"will not throw an error should there be minor differences. Thus by following "
"the standard guidelines in the Versioning APIs section you have no less a "
"problem than if you were implementing a RESTful API. \n"
"One of the benefits of RPC is that you can quickly generate a client for "
"your users, this allows an abstraction from both the transport and the "
"message type and allows them to depend upon an interface. As the creator you "
"can change the underlying implementation of your application such as a move "
"from Thrift to Proto buffers, without requiring the client to do anything "
"other than use the latest version of your provided client. Versioning also "
"allows you to retain the same backward compatibility that you can achieve "
"with REST. \n"
"RPC API design \n"
"Some of the principles we have just discussed for creating a good RESTful "
"API can also apply to RPC. However; one of the main differences is that you "
"may not be using HTTP as your transport; therefore you are not always going "
"to be able to use HTTP status codes as an indicator of success or failure. "
"RPC stands for Remote Procedure Call and dates way back before the Internet. "
"It was originally conceived as a way to execute a procedure that could be "
"running in a separate application on the same machine or even potentially on "
"the network. While we take this for granted now, back in the 90s this was "
"cutting edge. Unfortunately, frameworks such as CORBA and Java RMI gave RPC "
"a bad name and even now if you speak to an opponent of RPC they will most "
"likely bring these two frameworks up. The benefits, however, were "
"performance, using binary serialization is incredibly efficient on the "
"network and we no longer have the tight coupling that RMI and CORBA "
"enforced. We are also not trying to do anything too clever; we are no longer "
"attempting to share an object across two processes we are taking a more "
"functional approach, that is, methods that return immutable objects. This "
"gives us the best of both worlds; the simplicity of interoperation and the "
"speed and small payload of binary messages. \n"
"RPC message frameworks \n"
"These days we are no longer coupled to having the same interface "
"implementation on both the client and the server, this would not adhere to "
"our mantra of independently versionable and deployable. Thankfully "
"frameworks are more flexible we can take the same approach as we do with "
"REST, it is OK to add, however, removing elements or changing the signatures "
"of a method must trigger a version update. \n"
"Gob \n"
"We have already looked at gob in the previous chapter but as a quick re-cap, "
"the gob format was specifically designed to facilitate Go to Go-based "
"communication and was structured around the idea of something easier to use "
"and possibly more efficient than the likes of protocol buffers, this comes "
"at a cost of cross-language communication. \n"
"gob object definition: \n"
"type HelloWorldRequest struct {\n"
"  Name string \n"
"} \n"
"More information about gob can be found in the Go documentation at https://"
"golang.org /pkg/encoding/gob/ \n"
"Thrift \n"
"The Thrift framework was created by Facebook and was open sourced in 2007. "
"It is currently maintained by the Apache Software Foundation. The main aims "
"of Thrift are: "
msgstr ""

#: ch2.txt:460
msgid ""
"Simplicity: Thrift code is straightforward and approachable, free of "
"unnecessary dependencies "
msgstr ""

#: ch2.txt:462
msgid ""
"Transparency: Thrift conforms to the most common idioms in all languages "
msgstr ""

#: ch2.txt:464
msgid ""
"Consistency: Niche, language-specific features belong in extensions, not in "
"the core library "
msgstr ""

#: ch2.txt:476
msgid ""
"Performance: Strive for performance first, elegance second \n"
"This is a thrift service definition: \n"
"struct User {\n"
"  1: string name,  2: i32 id,\n"
"  3: string email } \n"
"struct Error {  1: i32 code,\n"
"  2: string detail } \n"
"service Users {\n"
"  Error createUser(1: User user) \n"
"} \n"
"Find more information on Apache Thrift at https://thrift.apache.org. "
msgstr ""

#: ch2.txt:495
msgid ""
"Protocol Bu.ers \n"
"Protocol Buffers are a Google product, and they have just entered their "
"third revision. Protocol Buffers take the approach of providing a DSL that "
"the generator (written in C) reads and can generate client and server stubs "
"for over ten languages, the primary ten are maintained by Google and "
"encompass: Go, Java, C, JavaScript for NodeJS. \n"
"Protocol Buffers is a pluggable architecture, so it is possible to write "
"your own plugins to generate all kinds of endpoints not just RPC; however, "
"RPC is the main use case as they are coupled to the gRPC framework. \n"
"gRPC was designed by Google to be a fast and language agnostic RPC "
"framework, which originated from an internal project where latency and speed "
"were of the utmost importance in Google's architecture. By default, gRPC "
"uses protocol buffers as the method for serializing and de-serializing "
"structured data. An example of this DSL is shown in the following example. \n"
"Protocol buffer service definition: \n"
"service Users {\n"
"  rpc CreateUser (User) returns (Error) {} \n"
"} \n"
"message User {\n"
"  required string name = 1;\n"
"  required int32 id = 2;\n"
"  optional string email = 3; \n"
"} \n"
"message Error {\n"
"  optional code int32 = 1\n"
"  optional detail string = 2 \n"
"} \n"
"Find more information on Protocol Buffers at https://developers.google.com/"
"protocol-buffers/. "
msgstr ""

#: ch2.txt:517
msgid ""
"JSON-RPC \n"
"JSON-RPC is an attempt at a standard way of representing objects for RPC "
"using JSON. This removes the need to decode any proprietary binary protocol "
"at the expense of transfer speed. There is no requirement for any particular "
"client or server to serve this data format, TCP sockets, and the ability to "
"write strings that pretty much most all programming languages can manage are "
"all you require. \n"
"Unlike Thrift and Protocol Buffers, JSON-RPC sets the standard for the "
"message serialization. \n"
"JSON-RPC implements some nice features that allow the batching of requests; "
"every request contains an id parameter, which is established by the client. "
"When the server responds it will return the same identifier allowing the "
"client to understand to which request a response relates. \n"
"This is a JSON-RPC serialized request: \n"
"{\n"
"  \"jsonrpc\": \"2.0\",\n"
"  \"method\": \"\": \"Users.v1.CreateUser\",\n"
"  \"params\": {\n"
"    \"name\": \"Nic Jackson\",\n"
"    \"id\": 12335432434\n"
"  },\n"
"  \"id\": 1 \n"
"} \n"
"This is a JSON-RPC serialized response: \n"
"{\n"
"  \"jsonrpc\": \"2.0\",\n"
"  \"result\": {...},\n"
"  \"id\":\": 1 \n"
"} \n"
"Find more information on JSON-RPC 2.0 at http://www.jsonrpc.org/"
"specification. "
msgstr ""

#: ch2.txt:521
msgid ""
"Filtering \n"
"When we looked at RESTful APIs we discussed the concept of using the query "
"string to perform filtering actions such as: "
msgstr ""

#: ch2.txt:523
msgctxt "ch2.txt:523"
msgid "Paging Filtering Sorting "
msgstr ""

#: ch2.txt:531
msgid ""
"Obviously, if we are writing an RPC API, we do not have the luxury of a "
"query string; however, implementing these concepts is incredibly useful. As "
"long as we are consistent there is no reason at all that we cannot define a "
"parameter on our request object for the filter condition: \n"
"{ \"jsonrpc\": \"2.0\", \"method\": \"\": \"Users.v1.GetUserLog\", \"params\""
": {\n"
"   \"name\": \"Nic Jackson\",   \"id\": 12335432434,   \"filter\": {\n"
"     \"page_start\":\": 1,  //optional     \"page_size\"\" : 10,  //"
"optional     \"sort\": \"name DESC\" //optional\n"
"   }, \"id\": 1 } \n"
"This is just an example and you will probably choose to implement something "
"specific to your own needs, however, the key is consistency. If we use this "
"same object for every method, we can be reasonably sure that our users will "
"be cool with this. "
msgstr ""

#: ch2.txt:539
msgid ""
"Versioning APIs \n"
"API versioning is something you should think about from the very beginning "
"and avoid as long as you can. In general, you will need to make changes to "
"your API, however, having to maintain n different versions can be a royal "
"pain in the backside, so doing the upfront design thinking at the beginning "
"can save you a whole load of trouble. \n"
"Before we look at how you can version your API, which is quite "
"straightforward let's look at when you should version. \n"
"You would increment your API version number when you introduce a breaking "
"change. \n"
"Breaking changes include: "
msgstr ""

#: ch2.txt:542
msgid ""
"Removing\n"
" or renaming APIs or API parameters "
msgstr ""

#: ch2.txt:546
msgid ""
"Changing\n"
" the type of an API parameter, for example, from integer to string "
msgstr ""

#: ch2.txt:550
msgid ""
"Changes\n"
" to response codes, error codes, or fault contracts "
msgstr ""

#: ch2.txt:554
msgid ""
"Changes\n"
" to the behavior of an existing API "
msgstr ""

#: ch2.txt:557
msgid "Things that do not involve a breaking change include: "
msgstr ""

#: ch2.txt:560
msgid ""
"Adding\n"
" parameters to a returned entity "
msgstr ""

#: ch2.txt:564
msgid ""
"Adding\n"
" additional endpoints or functionality "
msgstr ""

#: ch2.txt:568
msgid ""
"Bug\n"
" fixes or other maintenance that does not include items in the breaking "
"changes list "
msgstr ""

#: ch2.txt:573
msgid ""
"Semantic versioning \n"
"Microservices should implement the Major versioning scheme. Quite often, "
"designers will elect to only implement a Major version number and imply .0 "
"for the minor version as according to the semantic versioning principles "
"http://semver.org a Minor version would generally indicate the addition of "
"functionality that has been implemented in a backwards compatible way. This "
"could be adding additional endpoints to your API. It can be argued that "
"since this would not affect the client's ability to interact with your API "
"you should not worry about Minor versions and only concentrate on major as "
"the client will not need to request a particular version without these "
"additions in order to function. \n"
"When versioning APIs I think it is cleaner to drop the minor version and "
"only concentrate on major version. We would take this approach for two "
"reasons: "
msgstr ""

#: ch2.txt:576
msgid ""
"The\n"
" URI becomes more readable, and dots are only used as network location "
"separators. When using an RPC API dots are only used to separate "
"API.VERSION.METHOD and make everything easier to read. "
msgstr ""

#: ch2.txt:580
msgid ""
"We\n"
" should be inferring through our API versioning that change is a big thing "
"and has an impact on the function of the client. Internally we can still use "
"Major.Minor; however, this does not need to be something to the client as "
"they will not have the capability to elect to use minor versions of the API. "
msgstr ""

#: ch2.txt:592
msgid ""
"Versioning formats for REST APIs \n"
"To allow the client to request a particular API version, there are three "
"common ways you can do this. \n"
"It can be done as part of the URI: \n"
"https://myserver.com/v1/helloworld \n"
"It can also be done as a query string parameter: \n"
"https://myserver.com/helloworld?api-version=1 \n"
"Finally, It can be done by using a custom HTTP header: \n"
"GET https://myserver.com/helloworld api-version: 2 \n"
"Whichever way you implement versioning is up to you and your team, but it "
"should play a big part in your upfront design thinking. Once you have "
"decided on an option stick, to it as providing a consistent and great "
"experience for your consumers should be one of your primary goals. "
msgstr ""

#: ch2.txt:611
msgid ""
"Versioning formats for RPC APIs \n"
"Versioning RPC can be a little more difficult as most likely you are not "
"using HTTP as your transport. However, this is still possible. The best way "
"to deal with this is the namespace of your handlers. \n"
"In the go base packages, you have the capability to give your handler a "
"name, Greet.v1.HelloWorld. \n"
"Naming for RPC \n"
"With RPC you do not have the luxury of using HTTP verbs to confer the intent "
"of the API, for example, you have the collection users. With an HTTP API you "
"would be able to split up the various actions using GET, POST, DELETE, and "
"so on. This is not possible with an RPC API and you need to think in the "
"same way as if you were writing methods inside your Go code, so for example: "
"\n"
"GET /v1/users \n"
"The preceding code might be written as an RPC method as follows: \n"
"Users.v1.Users GET /v1/users/123434 \n"
"Alternatively, it might be written as an RPC method as follows: \n"
"Users.v1.User \n"
"Sub collections become a little less semantic, whereas in a RESTful API you "
"would be able to do the following: \n"
"GET /v1/users/12343/permissions/1232 \n"
"You cannot do this with an RPC API and you must explicitly specify the "
"method as a separate entity: \n"
"Permissions.v1.Permission \n"
"The method name also needs to infer the action that the API is going to "
"perform; you cannot rely on the use of HTTP verbs, so in the instance that "
"you have a method that can delete a user you would have to add the delete "
"verb into the method call, for example: \n"
"DELETE /v1/users/123123 \n"
"The preceding code would become: \n"
"Users.v1.DeleteUser "
msgstr ""

#: ch2.txt:623
msgid ""
"Object type standardization \n"
"Whether you are using custom binary serialization, JSON, or JSON-RPC you "
"need to think about how your user is going to handle the object at the other "
"side of the transaction. Many of the serialization packages Protocol Buffers "
"such as protocol buffers and Thrift that use stubs to generate client code "
"will happily deal with serialization of simple types such as Dates into "
"native types that enable your consumer to easily use and manipulate these "
"objects. However, if you are using JSON or JSON-RPC there is no concept of a "
"Date as a native type therefore it can be useful to fall back to ISO "
"standards which the user of the client can easily deserialize. The Microsoft "
"API design guidelines provide some good advice on how to handle Dates and "
"Durations. \n"
"Dates \n"
"When returning a date, you should always use the DateLiteral format and "
"preferably the Iso8601Literal. If you do need to send back a date in a "
"format other than Iso8601Literal, then you can use a StructuredDateLiteral "
"format, which allows you to specify the kind as part of the returned entity. "
"\n"
"The informal Iso8601Literal format is the simplest method to use and should "
"be understandable by almost any client consuming your API: \n"
"{\"date\": \"2016-07-14T16:00Z\"} \n"
"The more formal StucturedDateLiteral does not return a string, but an entity "
"that contains two properties, kind and value: \n"
"{\"date\": {\"kind\": \"U\", \"value\": 1471186826}} \n"
"The permissible kinds are: "
msgstr ""

#: ch2.txt:625
msgid "C: CLR; number of milliseconds since midnight January 1 00 "
msgstr ""

#: ch2.txt:627
msgid "E: ECMAScript; number of milliseconds since midnight, January 1, 1970 "
msgstr ""

#: ch2.txt:629
msgid "I: ISO 8601; a string limited to the ECMAScript subset "
msgstr ""

#: ch2.txt:631
msgid ""
"O: OLE Date; integral part is the number of days since midnight, December "
"31, 1899, and fractional part is the time within the day (0.5 = midday) "
msgstr ""

#: ch2.txt:633
msgid ""
"T: Ticks; number of ticks (100-nanosecond intervals) since midnight January "
"1, 1601 "
msgstr ""

#: ch2.txt:635
msgid "U: UNIX; number of seconds since midnight, January 1, 1970 "
msgstr ""

#: ch2.txt:637
msgid "W: Windows; number of milliseconds since midnight January 1, 1601 "
msgstr ""

#: ch2.txt:642
msgid ""
"X: Excel; as for O, but the year 1900 is incorrectly treated as a leap year, "
"and day 0 is \"January 0 (zero)\" \n"
"Durations \n"
"Durations are serialized to conform with ISO 8601 and are represented by the "
"following format: \n"
"P[n]Y[n]M[n]DT[n]H[n]M[n]S "
msgstr ""

#: ch2.txt:644
msgid ""
"P: This is the duration designator (historically called \"period\") placed "
"at the start of the duration representation "
msgstr ""

#: ch2.txt:646
msgid ""
"Y: This is the year designator that follows the value for the number of "
"years "
msgstr ""

#: ch2.txt:648
msgid ""
"M: This is the month designator that follows the value for the number of "
"months "
msgstr ""

#: ch2.txt:650
msgid ""
"W: This is the week designator that follows the value for the number of "
"weeks "
msgstr ""

#: ch2.txt:652
msgid ""
"D: This is the day designator that follows the value for the number of days "
msgstr ""

#: ch2.txt:654
msgid ""
"T: This is the time designator that precedes the time components of the "
"representation "
msgstr ""

#: ch2.txt:656
msgid ""
"H: This is the hour designator that follows the value for the number of "
"hours "
msgstr ""

#: ch2.txt:658
msgid ""
"M: This is the minute designator that follows the value for the number of "
"minutes "
msgstr ""

#: ch2.txt:661
msgid ""
"S: This is the second designator that follows the value for the number of "
"seconds \n"
"For example, P3Y6M4DT12H30M5S represents a duration of \"three years, six "
"months, four days, twelve hours, thirty minutes, and five seconds\". "
msgstr ""

#: ch2.txt:664
msgid ""
"Intervals \n"
"Again part of the ISO 8601 specification is if you need to receive or send "
"an interval you can use the following format: "
msgstr ""

#: ch2.txt:666
msgid "Start and end, such as 2007-03-01T13:00:00Z/2008-05-11T15:30:00Z "
msgstr ""

#: ch2.txt:669
msgid ""
"Start\n"
" and duration, such as 2007-03-01T13:00:00Z/P1Y2M10DT2H30M "
msgstr ""

#: ch2.txt:673
msgid ""
"Duration\n"
" and end, such as P1Y2M10DT2H30M/2008-05-11T15:30:00Z "
msgstr ""

#: ch2.txt:680
msgid ""
"Duration only, such as P1Y2M10DT2H30M, with additional context information \n"
"Find more information on JSON serialization of dates and times at \n"
"https://github.com/Microsoft/api-guidelines/blob/master/"
"Guidelines.md#113-json-\n"
"serialization-of-dates-and-times. "
msgstr ""

#: ch2.txt:687
msgid ""
"Documenting APIs \n"
"Documenting APIs is incredibly useful whether you intend the API to be "
"consumed internally by other teams in your company, external users, or even "
"only yourself. You will thank yourself for spending the time to document the "
"operations of the API and keep this up to date. Keeping documentation up to "
"date should not be an arduous task. There are many applications that can "
"generate documentation automatically from your source code, so all you need "
"to do is run this application as part of your build workflow. \n"
"REST based-based APIs \n"
"Currently three primary standards are fighting it out to become the queen of "
"REST API documentation: "
msgstr ""

#: ch2.txt:689
msgid "Swagger "
msgstr ""

#: ch2.txt:691
msgid "API Blueprint RAML "
msgstr ""

#: ch2.txt:706
msgid ""
"Swagger \n"
"Swagger was designed by SmartBear and has been chosen to be part of the Open "
"API Initiative; this potentially gives it the greatest chance of adoption as "
"a standard for documenting RESTful APIs. The Open API Initiative "
"(https://openapis.org) however is an industry body and whether it gains the "
"recognition that the W3C has around web standards is probably dependent on "
"more big names joining. \n"
"Documentation is written in YAML, and various code generation tools can both "
"write Swagger documentation from source code as well as being able to "
"generate client SDKs. The standard is comprehensive in its feature list and "
"is also relatively simple to write as well as being well understood by the "
"developer community. \n"
"The code example of Swagger is shown as follows: \n"
"/pets:  get:    description: Returns all pets from the system that the user "
"has access to    produces:\n"
"      - application/json\n"
"    responses:      '200''200': \n"
"        description: A list of pets.\n"
"  schema:    type: array    items:\n"
"      $ref: ''#/definitions/Pet'Pet' \n"
"definitions:\n"
"  Pet:    type: object    properties:\n"
"      name:  type: string    description: name of the pet \n"
"Find more information on Swagger at http://swagger.io. "
msgstr ""

#: ch2.txt:720
msgid ""
"API Blueprint \n"
"API Blueprint is an open standard designed by Apiary and released under the "
"MIT license. It ties closely into Apiary's products. However, it can be used "
"on its own, and there are a variety of open source tools that read and write "
"the format. \n"
"Documentation is written in Markdown, which can make authoring the "
"documentation feel a little more natural rather than dealing with nested "
"layers of objects. \n"
"The code example for API Blueprint is shown as follows: \n"
"FORMAT: 1A \n"
"# Data Structures \n"
"## Pet (object) \n"
"+ name: Jason (string) - Name of the pet. \n"
"# Pets [/pets] \n"
"Returns all pets from the system that the user has access to'to' \n"
"## Retrieve all pets [GET] \n"
"+\n"
" Response 200 (application/json) "
msgstr ""

#: ch2.txt:723
msgid ""
"+\n"
" Attributes (array[Pet]) "
msgstr ""

#: ch2.txt:726
msgid "Find more information on API Blueprint at https://apiblueprint.org. "
msgstr ""

#: ch2.txt:747
msgid ""
"RAML \n"
"RAML stands for RESTful API Modelling Language and is written in YAML "
"format. It aims to allow the definition of a human-readable format that "
"describes resources, methods, parameters, responses, media types, and other "
"HTTP constructs that form the basis of your API. \n"
"The code example for RAML is shown as follows: \n"
"#%RAML 1.0 \n"
"title: Pets API \n"
"mediaType: [ application/json] \n"
"types:\n"
"  Pet:\n"
"    type: object\n"
"    properties:\n"
"      name:\n"
"        type: string\n"
"        description: name of the pet \n"
"/pets:\n"
"  description: Returns all pets from the system that the user has access to\n"
"  get:\n"
"    responses:\n"
"      200:\n"
"        body: Pet[] \n"
"Find more information on RAML at http://raml.org. "
msgstr ""

#: ch2.txt:773
msgid ""
"RPC based-based APIs \n"
"With RPC APIs there is an argument that your contract is your documentation, "
"in the following example we define the interface using the protocol buffers "
"DSL and would make any necessary comments to assist the consumer as "
"required. The predominant theory to follow is one of self-documenting code "
"that your methods and parameter names should infer intent and enough "
"description to negate the use of comments. \n"
"Protocol buffer example: \n"
"// The greeting service definition. \n"
"service Users {\n"
"  // Create user creates a user in the system with the given User details,\n"
"  // it returns an Error message which will be nil on a successful \n"
"operation\n"
"  rpc CreateUser (User) returns (Error) {} \n"
"} \n"
"// Person describes a user entity \n"
"message User {\n"
"  // name is a required field and represents the name of\n"
"  required string name = 1;\n"
"  // id is the unique identifier for the user in the sytem\n"
"  required int32 id = 2;\n"
"  // email is the users email address and is an optional field\n"
"  optional string email = 3; \n"
"} \n"
"message Error {\n"
"  optional code int32 = 1\n"
"  optional detail string = 2 \n"
"} \n"
"Which standard you choose is entirely dependent on you, your workflow, your "
"team standards, and your users. It will vary from case to case, however, "
"once you choose an approach in the same way as you do with naming "
"conventions you should stick to a consistent style across all of your APIs. "
msgstr ""

#: ch2.txt:779
msgid ""
"Summary \n"
"In this chapter, we did not spend much time looking at code; however, we "
"have looked at some essential concepts around writing a great API, which is "
"as important as being able to write the code. \n"
"The bulk of this chapter has been concerned with RESTful APIs as unlike RPC "
"we need to be a little more descriptive in their use. We also have the "
"capability to leverage the principles of HATEOAS, which we do not have when "
"using RPC. \n"
"In the next chapter, we will start to look at some of the fantastic "
"frameworks that exist in the Go community, so we can start applying these "
"principles and furthering our advancement to microservice mastery. "
msgstr ""
